<!DOCTYPE html>
<html>
<head>
  <title>Chart.JS animation tests</title>
</head>
<body>
  <h1>Chart.JS</h1>

  <div class="chart"></div>

  <p>Please note that the data is completely fictional and has nothing to do with the Corona pandemic</p>
  <p><strong>The pie charts are under developement and will be ready soon</strong></p>

  <p>Type:
    <select onchange="changeData()">
      <option value="spline">Spline</option>
      <option value="bar">Bar</option>
      <option value="bezier">Bezier</option>
    </select>
  </p>
  <p>Options:
    <textarea onchange="changeData()" style="width: 50%; height: 50vh">var opts = {
      series: {
        name: "Corona Waves",
        type: "spline",
        data: DATA, // [30, 1, 20, 5, 10, 1, 100],
        style: {
          label: {
            format: "%value% unit(s)"
          }
        },
        options: {
          displayKnots: false
        }
      },
      xAxis: {
        start: "No Data",
        pointInterval: 10,
        data: [
          "1st wave", "", "2nd wave", "", "3rd wave"
        ]
      },
      yScale: {
        spaceComputing: "auto"
      },
      options: {
        animations: {
          enabled: true
        },
        dataGrouping: {
          enabled: true,
          groupCount: 2
        },
        drawRays: false,
        crossHair: {
          enabled: true
        }
      }
    }</textarea>
    Animation Wapoint count: <input onchange="changeData()" value="3"></input>
  </p>

  <script>
  function changeData() {
    var sel = document.querySelector("select");
    eval(document.querySelector("textarea").value);
    opts.series.type = sel.value;
    chart.env = {waypointCount: document.querySelector("input").value};
    chart.setData(opts);
  }
  </script>

  <script>
  function formatter() {
    return this;
  }
  function OptionHandler(opts) {
    var currentOptions = opts;
    var update = this.update = (updated) => {
      if (typeof updated == "object") {
        for (const prop in updated) {
          currentOptions[prop] = updated[prop];
        }
      } else {
        console.warn("Passed options are not 'typeof object'! Terminated option builder.");
      }
      return currentOptions
    }
    return this;
  }

  function PieChart() {
    var options = {
      style: {
        backgroundColor: "#282c34",
        uiColor: "#9da5b4",
        series: {
          colors: ["#f45b5b", "#749C14", "#C052A9", "#1369C3"],
          semiTransparent: "rgba(244, 91, 91, 1)"
        },
        tooltip: {
          background: ["#14161a", "#21252b"],
          color: "#9da5b4"
        }
      }
    }

    var chart = document.createElement("canvas");
    var ctx, width, height, center, rad;
    var data = {};
    var degrees = [], percentages = [], angles = [];
    var partColors = [];

    var getPoint = this.getPoint = (c1,c2,radius,angle) => {
      return [c1+Math.cos(angle)*radius,c2+Math.sin(angle)*radius];
    }

    var radians = this.radians = (degrees) => {
      return degrees * Math.PI / 180;
    }

    var drawPointAlgo = this.drawPointAlgo = (angle) => {
      // C (cos(90-alpha)*r + B.x | sin(90-alpha) * r + B.y)
      angle += 180;
      var point = {
        x: Math.cos(((90+angle) * Math.PI)/180) * rad + center.x,
        y: Math.sin(((90+angle) * Math.PI)/180) * rad + center.y
      }
      ctx.save();
      ctx.fillStyle = "red";
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.lineTo(center.x, center.y + rad);
      ctx.lineTo(point.x, point.y);
      ctx.lineTo(center.x, center.y);
      ctx.stroke();
      ctx.closePath();
      ctx.beginPath();
      ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.closePath();
      ctx.restore();
    }

    var algoTest = this.algoTest = (min, max, interval) => {
      let curr = min;
      while (curr <= max) {
        drawPointAlgo(curr);
        curr += interval;
      }
    }

    var getArcPoint = this.getArcPoint = (c, r, angle) => {
      // C (cos(90-alpha)*r + B.x | sin(90-alpha) * r + B.y)
      angle += 180;
      var point = {
        x: Math.cos(((90+angle) * Math.PI)/180) * r + c.x,
        y: Math.sin(((90+angle) * Math.PI)/180) * r + c.y
      }
      return point;
    }

    var update = this.update = () => {
      if (degrees) {
        ctx.save();
        ctx.fillStyle = options.style.backgroundColor;
        ctx.fillRect(0, 0, width, height);
        var colors = options.style.series.colors.slice();

        let a = 0;
        for (let i = 0; i < angles.length; i++) {
          let part = angles[i] - 90;
          let start = (i == 0) ? -90 : angles[i - 1] - 90;
          if (colors.length == 0) {colors = options.style.series.colors.slice()}
          var rand = Math.floor(Math.random() * colors.length);
          ctx.fillStyle = colors[rand];
          ctx.strokeStyle = options.style.backgroundColor;

          ctx.beginPath();
          ctx.moveTo(center.x, center.y);
          ctx.arc(center.x, center.y, rad, radians(start), radians(part));
          ctx.moveTo(center.x, center.y);
          ctx.stroke();
          ctx.fill();
          ctx.closePath();
          colors.splice(rand, 1);
        }
        ctx.restore();
      }
    }

    var compare = this.compare = (a,b) => {
      if (parseFloat(a) < parseFloat(b)) {
        return -1;
      } else if (parseFloat(a) > parseFloat(b)) {
        return 1;
      }
      return 0;
    }

    var setData = this.setData = (newData) => {
      data = newData;

      if (data.options) {
        var optionHandler = new OptionHandler(options);
        options = optionHandler.update(data.options);
      }

      if (data.series) {
        var percent = data.series.reduce((prev, curr) => prev + curr) / 100;
        data.series.forEach((seriesData, i) => {
          percentages.push(seriesData / percent);
          degrees.push((seriesData / percent) * 3.6);
        });
        degrees = degrees.sort(compare);
        let prev = 0;
        degrees.forEach((val, i) => {
          angles.push(val + prev);
          prev += val;
        });
      }

      ctx.clearRect(0, 0, width, height);

      ctx.fillStyle = options.style.backgroundColor;
      ctx.fillRect(0, 0, width, height);

      update();
    }

    var render = this.render = (opts) => {
      let container = document.querySelector(".chart");
      if (opts.container) {
        if ((typeof opts.container).toLowerCase() == "string") {
          container = document.querySelector(opts.container);
        } else {
          container = opts.container;
        }
      }
      container.appendChild(chart);
      chart.width = (!opts.width) ? 600 : opts.width;
      chart.height = (!opts.height) ? 300 : opts.height;
      chart.addEventListener("mousemove", function(event) {
        /*var mousepos = getMousePos(event);
        handleHover(mousepos.x, mousepos.y);*/
      });
      chart.addEventListener("mouseout", function(event) {
        currentNearestPoint = null;
        update();
      });

      width = chart.getBoundingClientRect().width; // value init
      height = chart.getBoundingClientRect().height;
      ctx = chart.getContext("2d");
      center = {x: width / 2, y: height / 2};
      rad = (height < width) ? (height - 20) / 2 : (width - 20) / 2

      update();
    }
    return this;
  }

  var pie = new PieChart();
  pie.render({});
  pie.setData({
    series: [
      30, 1, 20, 5, 10, 1, 100
    ]
  });

  function Chart() {
    var width = 0; var height = 0;
    var options = {
      style: {
        backgroundColor: "#282c34",
        uiColor: "#9da5b4",
        series: {
          color: "#f45b5b",
          semiTransparent: "rgba(244, 91, 91, 1)"
        },
        tooltip: {
          background: ["#14161a", "#21252b"],
          color: "#9da5b4"
        }
      },
      dataGrouping: {
        enabled: false,
        groupCount: 10
      },
      crossHair: {
        enabled: true,
        dot: false
      },
      barWidth: 20,
      drawRays: false,
      scaleSteps: 8
    }
    var envVars = {
      horizontalSpace: 0,
      verticalMultiplier: 1,
      highestValue: 0,
      waypointCount: 10,
      waypointArrayLength: 0
    }

    Object.defineProperties(this, {
        "env": {
             "get": function() {
               return envVars;
             },
             "set": function(newEnv) {
               return envVars = new OptionHandler(envVars).update(newEnv);
             }
        },
        "options": {
          "get": function() {
            return options;
          },
          "set": function(newOpts) {
            return options = new OptionHandler(options).update(newOpts);
          }
        },
        "data": {
          "get": function() {
            return data;
          },
          "set": function() {console.warn("Please use chart.setData() to set a new dataset.");}
        },
        "chartElement": {
          "get": function() {
            return chart;
          },
          "set": function() {}
        }
    });

    var chart = document.createElement("canvas");
    var tooltip = document.createElement("div");

    var ctx;
    var widthDataOffset = 40;
    var heightDataOffset = 30;

    var xAxisPoints = [];
    var currentNearestPoint = null;

    var data = {
      /*series: {},
      xAxis: {}*/
    }, originalData = {};

    this.properties = {
      get context() {
        return ctx;
      }
    };

    var quicksort = this.quicksort = (numbers) => {
      if (numbers.length >= 1) {
        var pivot = numbers[Math.floor(Math.random()*numbers.length)];
        var smaller = [], bigger = [], pivots = [];
        for (let i = 0; i < numbers.length; i++) {
          if (numbers[i] != pivot) {
            if (numbers[i] < pivot) {
              smaller.push(numbers[i]);
            } else if (numbers[i] > pivot){
              bigger.push(numbers[i]);
            } else {smaller.push(numbers[i])}
          } else {pivots.push(pivot)}
        }
        bigger = quicksort(bigger);
        smaller = quicksort(smaller);
        numbers = smaller.concat(pivots).concat(bigger);
      }
      return numbers;
    }

    var drawTooltip = this.drawTooltip = (x, y, text) => {
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = options.style.tooltip.background[0];

      var boxWidth = ctx.measureText(text).width + 10;
      let metrics = ctx.measureText(text);
      let actualTextHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
      var boxHeight = actualTextHeight + 10;

      ctx.beginPath();

      var modifier = 0;
      var triangleModifier = 0;
      var factor = 1;
      if (boxWidth + x > width) {
        modifier = (boxWidth + 40) * (-1);
        triangleModifier = modifier + boxWidth;
        factor = (-1);
      }

      ctx.moveTo(x + triangleModifier, y);
      ctx.lineTo(x  + (-10)*factor + triangleModifier, y + boxHeight / 2);
      ctx.lineTo(x + triangleModifier, y + boxHeight);
      ctx.lineTo(x + 1*factor + triangleModifier, y + boxHeight);
      ctx.lineTo(x + 1*factor + triangleModifier, y);
      ctx.fill();

      ctx.closePath();

      ctx.fillRect(x + modifier, y, boxWidth, boxHeight);
      ctx.closePath();

      ctx.beginPath();
      ctx.fillStyle = options.style.tooltip.color;
      ctx.fillText(text, x + 5 + modifier, y + 2.5 + actualTextHeight);

      ctx.closePath();
      ctx.restore();
    }

    var getMousePos = this.getMousePos = (evt) => {
      var rect = chart.getBoundingClientRect(), // abs. size of element
          scaleX = chart.width / chart.width,    // relationship bitmap vs. element for X
          scaleY = chart.height / rect.height;  // relationship bitmap vs. element for Y

      return {
        x: (evt.clientX - rect.left) * scaleX,   // scale mouse coordinates after they have
        y: (evt.clientY - rect.top) * scaleY     // been adjusted to be relative to element
      }
    }

    var getClosestPoint = this.getClosestPoint = (x, y) => {
      var horizontalSpace = (width - widthDataOffset * 2) / data.series.data.length;
      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;
      var distances = [];
      data.series.data.forEach((point, i) => {
        var a = (widthDataOffset + 1 + ((i + 1) * horizontalSpace)) - x;
        var b = ((height - heightDataOffset) - point * verticalMultiplier) - y;
        distances.push([Math.sqrt(a*a + b*b), i]);
      });

      function sortDistances(numbers) {
        if (numbers.length >= 1) {
          var pivot = numbers[Math.floor(Math.random()*numbers.length)];
          var smaller = [], bigger = [], pivots = [];
          for (let i = 0; i < numbers.length; i++) {
            if (numbers[i][0] != pivot[0]) {
              if (numbers[i][0] < pivot[0]) {
                smaller.push(numbers[i]);
              } else if (numbers[i][0] > pivot[0]){
                bigger.push(numbers[i]);
              } else {smaller.push(numbers[i])}
            } else {pivots.push(pivot)}
          }
          bigger = sortDistances(bigger);
          smaller = sortDistances(smaller);
          numbers = smaller.concat(pivots).concat(bigger);
        }
        return numbers;
      }

      distances = sortDistances(distances);
      return distances[0][1];
    }

    var drawRays = this.drawRays = (x, y) => {
      ctx.save();
      var horizontalSpace = (width - widthDataOffset * 2) / data.series.data.length;
      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;
      data.series.data.forEach((point, i) => {
        ctx.beginPath();
        ctx.strokeStyle = "green";
        ctx.moveTo(x, y);
        ctx.lineTo((widthDataOffset + 1 + ((i + 1) * horizontalSpace)), ((height - heightDataOffset) - point * verticalMultiplier));
        ctx.stroke();
        ctx.closePath();
      });
      ctx.restore();
    }

    var handleHover = this.handleHover = (x, y) => {
      switch (data.series.type) {
        case "spline":
          if ((x > widthDataOffset && x < width - widthDataOffset) && (y > heightDataOffset && y < height - heightDataOffset)) {
            var point = getClosestPoint(x, y);
            if (currentNearestPoint != point || options.crossHair.enabled || options.drawRays) update(point);

            if (options.drawRays) drawRays(x, y);

            ctx.save();
            if (options.crossHair.enabled === true) {
              ctx.beginPath();
              ctx.strokeStyle = options.style.uiColor;

              ctx.moveTo(widthDataOffset, y);
              ctx.lineTo(x, y);

              ctx.moveTo(x, height - heightDataOffset);
              ctx.lineTo(x, y);

              ctx.stroke();
              ctx.closePath();

              if (options.crossHair.dot === true) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.closePath();
              }
            }

            ctx.beginPath();
            ctx.fillStyle = options.style.uiColor;
            ctx.font = "normal 15px normal";

            var horizontalSpace = ((width - (widthDataOffset * 2)) / data.series.data.length);
            var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
            var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;
            //ctx.fillText(data.series.data[point], widthDataOffset + horizontalSpace * (point + 1) + 7, height - heightDataOffset - data.series.data[point] * verticalMultiplier + 4);
            ctx.stroke();

            if (currentNearestPoint != point || options.drawRays || options.crossHair.enabled) {
              drawTooltip(widthDataOffset + 20 + ((point + 1) * horizontalSpace), (height - heightDataOffset) - data.series.data[point]*verticalMultiplier - 10, data.series.style.label.format.replace(/%value%/g, data.series.data[point]));
              currentNearestPoint = point;
            }

            ctx.closePath();
            ctx.restore();
          } else if (x < widthDataOffset || x > width - widthDataOffset || y < heightDataOffset || y > height - heightDataOffset) {
            update();
          }
          break;
        case "bar":
          if ((x > widthDataOffset && x < width - widthDataOffset) && (y > heightDataOffset && y < height - heightDataOffset)) {
            var point = getClosestPoint(x, y);
            update(point);

            ctx.save();
            ctx.beginPath();

            ctx.strokeStyle = options.style.uiColor;
            ctx.moveTo(widthDataOffset, y);
            ctx.lineTo(x, y);

            ctx.moveTo(x, height - heightDataOffset);
            ctx.lineTo(x, y);

            ctx.stroke();
            ctx.closePath();
            ctx.restore();
          } else if (x < widthDataOffset || x > width - widthDataOffset || y < heightDataOffset || y > height - heightDataOffset) {
            update();
          }
          break;
        case "bezier":
          if ((x > widthDataOffset && x < width - widthDataOffset) && (y > heightDataOffset && y < height - heightDataOffset)) {
            var point = getClosestPoint(x, y);
            if (currentNearestPoint != point || options.crossHair.enabled || options.drawRays) update(point);

            if (options.drawRays) drawRays(x, y);

            ctx.save();
            if (options.crossHair.enabled === true) {
              ctx.beginPath();
              ctx.strokeStyle = options.style.uiColor;

              ctx.moveTo(widthDataOffset, y);
              ctx.lineTo(x, y);

              ctx.moveTo(x, height - heightDataOffset);
              ctx.lineTo(x, y);

              ctx.stroke();
              ctx.closePath();

              if (options.crossHair.dot === true) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI, false);
                ctx.fill();
                ctx.closePath();
              }
            }

            ctx.beginPath();
            ctx.fillStyle = options.style.uiColor;
            ctx.font = "normal 15px normal";

            var horizontalSpace = ((width - (widthDataOffset * 2)) / data.series.data.length);
            var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
            var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;
            //ctx.fillText(data.series.data[point], widthDataOffset + horizontalSpace * (point + 1) + 7, height - heightDataOffset - data.series.data[point] * verticalMultiplier + 4);
            ctx.stroke();

            if (currentNearestPoint != point || options.drawRays || options.crossHair.enabled) {
              drawTooltip(widthDataOffset + 20 + ((point + 1) * horizontalSpace), (height - heightDataOffset) - data.series.data[point]*verticalMultiplier - 10, data.series.style.label.format.replace(/%value%/g, data.series.data[point]));
              currentNearestPoint = point;
            }

            ctx.closePath();
            ctx.restore();
          } else if (x < widthDataOffset || x > width - widthDataOffset || y < heightDataOffset || y > height - heightDataOffset) {
            update();
          }
          break;
        default:
          if ((x > widthDataOffset && x < width - widthDataOffset) && (y > heightDataOffset && y < height - heightDataOffset)) {
            var point = getClosestPoint(x, y);
            update(point);

            ctx.save();
            ctx.beginPath();

            ctx.strokeStyle = options.style.uiColor;
            ctx.moveTo(widthDataOffset, y);
            ctx.lineTo(x, y);

            ctx.moveTo(x, height - heightDataOffset);
            ctx.lineTo(x, y);

            ctx.stroke();
            ctx.closePath();
            ctx.restore();
          } else if (x < widthDataOffset || x > width - widthDataOffset || y < heightDataOffset || y > height - heightDataOffset) {
            update();
          }
          break;
      }
    }

    var handleScroll = this.handleScroll = (event) => {

    }

    var xAxis = this.xAxis = () => {
      if (!data.xAxis.pointInterval) data.xAxis.pointInterval = 1;
      ctx.save();
      ctx.beginPath();
      ctx.translate(widthDataOffset + 1, (height - heightDataOffset) - 5);

      ctx.strokeStyle = options.style.uiColor;
      ctx.fillStyle = options.style.uiColor;
      ctx.lineWidth = 1;
      var horizontalSpace = (width - (widthDataOffset * 2)) / data.series.data.length;

      ctx.moveTo(0, 0);
      ctx.lineTo(0, 10);
      ctx.stroke();
      data.xAxis.data.forEach((point, i) => {
        ctx.moveTo(((i + 1)*data.xAxis.pointInterval*horizontalSpace), 0);
        ctx.lineTo(((i + 1)*data.xAxis.pointInterval*horizontalSpace), 10);
        ctx.stroke();

        ctx.fillText(point, (i + 1) * data.xAxis.pointInterval * horizontalSpace - (ctx.measureText(point).width / 2), 20);
      });
      if (data.xAxis.start) {
        ctx.moveTo(0, 0);
        ctx.fillText(data.xAxis.start, (ctx.measureText(data.xAxis.start).width / 2 * (-1)), 20);
      }
      ctx.closePath();
      ctx.restore();
    }

    var yAxis = this.yAxis = () => {
      ctx.save();

      ctx.lineWidth = 2;
      ctx.strokeStyle = options.style.uiColor;

      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;

      var scaleSteps = options.scaleSteps;
      for (let i = 1; i <= scaleSteps; i++) {
        ctx.beginPath();
        let value = highestValue / scaleSteps * i;
        ctx.moveTo(widthDataOffset - 5, (height - heightDataOffset) - value*verticalMultiplier);
        ctx.lineTo(widthDataOffset + 5, (height - heightDataOffset) - value*verticalMultiplier);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.direction = "rlt";
        ctx.fillStyle = options.style.uiColor;
        ctx.fillText(value, (widthDataOffset - ctx.measureText(value.toString()).width) / 2, (height - heightDataOffset) + 3 - value*verticalMultiplier);
        ctx.closePath();
      }
      ctx.restore();
    }

    var drawSpline = this.drawSpline = (highlighted) => {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = options.style.series.color;
      ctx.fillStyle = options.style.series.color;

      var horizontalSpace = (width - (widthDataOffset * 2)) / data.series.data.length;

      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;

      if (data.series.options.displayKnots) {
        ctx.beginPath();
        ctx.arc(widthDataOffset + 1, (height - heightDataOffset), 3, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.closePath();
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.lineJoin = "round";
      data.series.data.forEach((seriesData, i) => {
        seriesData *= verticalMultiplier;
        if (data.series.options.displayKnots) {
          ctx.beginPath();
          ctx.arc(widthDataOffset + 1 + ((i + 1) * horizontalSpace), (height - heightDataOffset) - seriesData, 3, 0, 2 * Math.PI, false);
          ctx.fill();
          ctx.closePath();
          ctx.stroke();
        }

        if (i != 0) {
          ctx.moveTo(widthDataOffset + 1 + ((i + 0) * horizontalSpace), (height - heightDataOffset) - data.series.data[i - 1] * verticalMultiplier);
        } else {
          ctx.moveTo(widthDataOffset + 1, (height - heightDataOffset));
        }
        ctx.lineTo(widthDataOffset + 1 + ((i + 1) * horizontalSpace), (height - heightDataOffset) - seriesData);
        ctx.stroke();
      });
      ctx.closePath();

      if (highlighted && data.series.options.displayKnots) {
        ctx.beginPath();
        ctx.fillStyle = options.style.series.semiTransparent;
        ctx.arc(widthDataOffset + 1 + ((highlighted + 1) * horizontalSpace), (height - heightDataOffset) - data.series.data[highlighted] * verticalMultiplier, 4, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
      }

      ctx.restore();
    }

    var drawBars = this.drawBars = (highlighted) => {
      ctx.save();
      ctx.fillStyle = options.style.series.color;
      var horizontalSpace = (width - (widthDataOffset * 2)) / data.series.data.length;

      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;

      data.series.data.forEach((seriesData, i) => {
        ctx.beginPath();
        ctx.fillRect(widthDataOffset + 1 + (i + 1) * horizontalSpace - (options.barWidth / 2), height - heightDataOffset - seriesData * verticalMultiplier - 1, options.barWidth, seriesData * verticalMultiplier);
        ctx.closePath();
      });
      ctx.restore();
    }

    var drawBezier = this.drawBezier = (highlighted) => {
      ctx.save();
      ctx.fillStyle = options.style.series.color;
      ctx.strokeStyle = options.style.series.color;

      for (let i = 0; i <= data.series.data.length; i++) {
        let start = {
          x: widthDataOffset + 1 + ((i + 1) * envVars.horizontalSpace),
          y: (height - heightDataOffset) - data.series.data[i] * envVars.verticalMultiplier
        };
        let end = {
          x: widthDataOffset + 1 + ((i + 2) * envVars.horizontalSpace),
          y: (height - heightDataOffset) - data.series.data[i + 1] * envVars.verticalMultiplier
        }
        if (i == 0) {
          start.x = widthDataOffset + 1;
          start.y = height-heightDataOffset
        }
        let cp1 = {
          x: start.x + (end.x - start.x) / 2,
          y: start.y
        }
        let cp2 = {
          x: start.x + (end.x - start.x) / 2,
          y: end.y
        }
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
        ctx.stroke();
        ctx.closePath();
        if (i != 0) {
          if (data.series.options.displayKnots) {
            ctx.beginPath();
            ctx.arc(widthDataOffset + 1 + ((i + 1) * envVars.horizontalSpace), (height - heightDataOffset) - data.series.data[i] * envVars.verticalMultiplier, 3, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.closePath();
          }
        } else {
          if (data.series.options.displayKnots) {
            ctx.beginPath();
            ctx.arc(widthDataOffset + 1, (height - heightDataOffset), 3, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.closePath();
          }
        };
      }
      if (highlighted && data.series.options.displayKnots) {
        ctx.beginPath();
        ctx.fillStyle = options.style.series.semiTransparent;
        ctx.arc(widthDataOffset + 1 + ((highlighted + 1) * envVars.horizontalSpace), (height - heightDataOffset) - data.series.data[highlighted] * envVars.verticalMultiplier, 4, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
      }
      ctx.restore();
    }

    var update = this.update = (highlighted) => {
      ctx.lineJoin = "round";
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = options.style.backgroundColor; // background color
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = options.style.uiColor; // UI
      ctx.strokeStyle = options.style.uiColor;
      ctx.lineWidth = 1;
      ctx.moveTo(widthDataOffset, height - heightDataOffset);
      ctx.lineTo(width - widthDataOffset, height - heightDataOffset);
      ctx.moveTo(widthDataOffset, heightDataOffset);
      ctx.lineTo(widthDataOffset + 1, height - heightDataOffset);
      ctx.stroke();
      ctx.closePath();
      ctx.restore();

      if (data.series) {
        xAxis();
        yAxis();

        if (data.series.name) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(0, 20);

          ctx.fillStyle = options.style.series.color;
          ctx.font = "normal 16px Calibri";
          let x = (widthDataOffset / 2 - (ctx.measureText(data.series.name).width / 2) >= 2) ? widthDataOffset / 2 - (ctx.measureText(data.series.name).width / 2) : 2;
          ctx.fillText(data.series.name, x, 0);

          ctx.closePath();
          ctx.restore();
        }

        switch (data.series.type) {
          case "spline":
            drawSpline(highlighted);
            break;
          case "bar":
            drawBars(highlighted);
            break;
          case "bezier":
            drawBezier(highlighted);
            break;
          case "pie":
            break;
        }
      }
    }

    // calc waypoints traveling along vertices
    function calcWaypoints(vertices){
      var waypoints=[];
      for(var i=1;i<vertices.length;i++){
        var pt0=vertices[i-1];
        var pt1=vertices[i];
        var dx=pt1.x-pt0.x;
        var dy=pt1.y-pt0.y;
        for(var j=0;j<envVars.waypointCount;j++){
          var x=pt0.x+dx*j/envVars.waypointCount;
          var y=pt0.y+dy*j/envVars.waypointCount;
          waypoints.push({x:x,y:y});
        }
      }
      return(waypoints);
    }

    function calcLinearWaypoints(barVertices, factor) {
      var waypoints = [];
      for (let index = 0; index < barVertices.length; index++) {
        let vertices = barVertices[index];
        var pt0 = vertices[0];
        var pt1 = vertices[1];
        var dx = pt1.x - pt1.x;
        var dy = pt1.y - pt0.y;
        for (let i = 0; i < envVars.waypointCount; i++) {
          // f(x)=-0.75x
          var val = (-0.75) * i;
          var x=pt0.x+dx*val/(envVars.waypointCount);
          var y=pt0.y+dy*val/(envVars.waypointCount);
          waypoints.push({x:x,y:y});
        }
      }
      return waypoints;
    }

    var points;
    var t = 1, loopCount = 1, currentBar = 0;
    var drawAnimatedSpline = this.animatedSpline = () => {
      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineWidth = 2;
      ctx.strokeStyle = options.style.series.color;
      ctx.fillStyle = options.style.series.color;
      /*ctx.beginPath();
      var i = Math.floor(t / envVars.waypointCount);
      ctx.arc(widthDataOffset + 1 + envVars.horizontalSpace * data.series.data[i], (height - heightDataOffset) - data.series.data[i] * envVars.verticalMultiplier, 3, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.closePath();
      ctx.stroke();*/
      if(t<points.length-1){ requestAnimationFrame(drawAnimatedSpline); } else { t = 1; update(); }

      ctx.beginPath();
      ctx.moveTo(points[t-1].x,points[t-1].y); // draw a line segment from the last waypoint
      ctx.lineTo(points[t].x,points[t].y); // to the current waypoint
      ctx.stroke();
      ctx.restore();
      t++;
    }
    var drawAnimatedBars = this.animatedBars = () => {
      if(t<points[0].length-1){
        requestAnimationFrame(drawAnimatedBars);
      } else if (currentBar>=points.length - 1) {
        t = 1;
        currentBar = 0;
        update();
      } else if (currentBar<points.length - 1){
        requestAnimationFrame(drawAnimatedBars);
      }

      var x = points[currentBar][t].x - options.barWidth / 2;
      var y1 = points[currentBar][t - 1].y;
      var y2 = (-1) * Math.abs(points[currentBar][t].y - y1);
      ctx.save();
      ctx.beginPath();
      ctx.lineJoin = "round";
      ctx.lineWidth = 2;
      ctx.strokeStyle = options.style.series.color;
      ctx.fillStyle = options.style.series.color;
      ctx.fillRect(x, y1 - data.series.data[currentBar] * envVars.verticalMultiplier, options.barWidth, y2);
      if (!points[currentBar][t + 1]) {
        t = 1;
        currentBar++;
      }
      ctx.restore();
      t++;
      loopCount++;
    }

    var setData = this.setData = (newData) => {
      data = newData;

      if (data.series.data) {
        if (options.yScale) {
          if (options.yScale.spaceComputing == "auto") {
            var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
            var widths = [];
            var scaleSteps = options.scaleSteps;
            for (let i = 1; i <= scaleSteps; i++) {
              let value = highestValue / scaleSteps * i;
              widths.push(ctx.measureText(value));
            };
            widths.sort();
            let val = widths[widths.length - 1];

            var length = ctx.measureText(val).width;
            var res = (widthDataOffset - 11) - length;
            if (res < 0) {
              widthDataOffset += Math.abs(res);
            }
          } else if (options.yScale.spaceComputing == "highestValue") {
            var length = ctx.measureText(highestValue).width;
            var res = (widthDataOffset - 11) - length;
            if (res < 0) {
              widthDataOffset += Math.abs(res);
            }
          }
        } else {
          var length = ctx.measureText(highestValue).width;
          var res = (widthDataOffset - 11) - length;
          if (res < 0) {
            widthDataOffset += Math.abs(res);
          }
        }
      }

      if (data.options) {
        var optionHandler = new OptionHandler(options);
        options = optionHandler.update(data.options);
      }

      if (data.options.dataGrouping.enabled) {
        originalData = data;
        let grouped = [];
        let groupCount = options.dataGrouping.groupCount;
        for (let i = 0; i < data.series.data.length; i+=groupCount) {
          if (data.series.data[i]) {
            let tmp = [];
            for (let j = i; j < i + groupCount; j++) {
              if (data.series.data[j]) {
                tmp.push(data.series.data[j]);
              } else {break;}
            }
            grouped.push(tmp.reduce((prev, curr) => prev + curr) / tmp.length);
          } else {break;}
        }
        data.series.data = grouped;
      }

      var horizontalSpace = (width - (widthDataOffset * 2)) / data.series.data.length;
      envVars.horizontalSpace = horizontalSpace;

      data.xAxis.data.forEach((point, i) => {
        xAxisPoints.push(widthDataOffset + (i + 1) * horizontalSpace);
      });

      ctx.clearRect(0, 0, width, height);

      var highestValue = quicksort(data.series.data)[data.series.data.length - 1];
      var verticalMultiplier = (height - (heightDataOffset * 2) - 10) / highestValue;

      envVars.highestValue = highestValue;
      envVars.verticalMultiplier = verticalMultiplier;

      ctx.lineJoin = "miter";
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = options.style.backgroundColor; // background color
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = options.style.uiColor; // UI
      ctx.strokeStyle = options.style.uiColor;
      ctx.lineWidth = 1;
      ctx.moveTo(widthDataOffset, height - heightDataOffset);
      ctx.lineTo(width - widthDataOffset, height - heightDataOffset);
      ctx.moveTo(widthDataOffset, heightDataOffset);
      ctx.lineTo(widthDataOffset + 1, height - heightDataOffset);
      ctx.stroke();
      ctx.closePath();
      ctx.restore();

      if (data.series) {
        xAxis();
        yAxis();

        if (data.series.name) {
          ctx.save();
          ctx.beginPath();
          ctx.translate(0, 20);

          ctx.fillStyle = options.style.series.color;
          ctx.font = "normal 16px Calibri";
          let x = (widthDataOffset / 2 - (ctx.measureText(data.series.name).width / 2) >= 2) ? widthDataOffset / 2 - (ctx.measureText(data.series.name).width / 2) : 2;
          ctx.fillText(data.series.name, x, 0);

          ctx.closePath();
          ctx.restore();
        }

        if (!data.options.animations.enabled) {
          update();
        } else {
          switch (data.series.type) {
            case "spline":
              var vertices = [];
              vertices.push({x:widthDataOffset + 1, y: height - heightDataOffset});
              data.series.data.forEach((seriesData, i) => {
                vertices.push({x: widthDataOffset + 1 + ((i + 1) * horizontalSpace), y: (height - heightDataOffset) - seriesData * verticalMultiplier});
              });
              points = calcWaypoints(vertices);
              window.requestAnimationFrame(drawAnimatedSpline);
              break;
            case "bar":
              var vertices = [];
              data.series.data.forEach((seriesData, i) => {
                let start = {x: widthDataOffset + 1 + ((i + 1) * horizontalSpace), y: (height - heightDataOffset)};
                let end = {x: widthDataOffset + 1 + ((i + 1) * horizontalSpace), y: (height - heightDataOffset) - seriesData * verticalMultiplier};
                vertices.push([start, end]);
              });
              points = calcLinearWaypoints(vertices);
              envVars.waypointArrayLength = points.length;
              barWaypoints = [];
              var lastX = 0;
              var currentIndex = -1;
              points.forEach((point, i) => {
                if (point.x != lastX) {
                  lastX = point.x;
                  barWaypoints[++currentIndex] = [point];
                } else {
                  barWaypoints[currentIndex].push(point);
                }
              });
              points = barWaypoints;
              window.requestAnimationFrame(drawAnimatedBars);
              break;
            case "bezier":
              drawBezier(); // TODO: animate bezier curve
              break;
          }
        }
      }
    };

    var render = this.render = (opts) => {
      let container = document.querySelector(".chart");
      if (opts.container) {
        if ((typeof opts.container).toLowerCase() == "string") {
          container = document.querySelector(opts.container);
        } else {
          container = opts.container;
        }
      }
      container.appendChild(chart);
      chart.width = (!opts.width) ? 600 : opts.width;
      chart.height = (!opts.height) ? 300 : opts.height;
      chart.addEventListener("mousemove", function(event) {
        var mousepos = getMousePos(event);
        handleHover(mousepos.x, mousepos.y);
      });
      chart.addEventListener("mouseout", function(event) {
        currentNearestPoint = null;
        update();
      });
      chart.addEventListener("mousewheel", function(event) {
        handleScroll(event); // TODO: Zooming
      });

      width = chart.getBoundingClientRect().width; // value init
      height = chart.getBoundingClientRect().height;
      ctx = chart.getContext("2d");

      update();
    }
    return this;
  }

  var DATA = [1208, 1215, 1215, 1220, 1224, 1229, 1251, 1253, 1268, 1268, 1273, 1279, 1284, 1288, 1290, 1304, 1307, 1309, 1310, 1315, 1322, 1337, 1345, 1354, 1363, 1366, 1380, 1394, 1396, 1397, 1407, 1412, 1419, 1426, 1437, 1447, 1448, 1448, 1448, 1452, 1457, 1457, 1438, 1430, 1422, 1392, 1343, 1285, 1258, 1253, 1175, 1141, 1127, 1092, 1072, 1000, 791, 750, 668, 826, 885, 1003, 1118, 1185, 1321, 1771, 1710, 1688, 1451, 1401, 1302, 1183, 998, 899, 786, 769, 755, 766, 804, 842, 940, 1225, 1274, 1236, 1217, 1133, 1106, 1098, 1171, 1153, 1133, 1111, 1088, 1064, 1021, 961, 892, 856, 949, 1169];

  var chart = new Chart();
  chart.render({height:400, width: 900});
  chart.env = {waypointCount: 3};
  chart.setData({
    series: {
      name: "Corona Waves",
      type: "spline",
      data: DATA, // [30, 1, 20, 5, 10, 1, 100],
      style: {
        label: {
          format: "%value% unit(s)"
        }
      },
      options: {
        displayKnots: false
      }
    },
    xAxis: {
      start: "No Data",
      pointInterval: 10,
      data: [
        "1st wave", "", "2nd wave", "", "3rd wave"
      ]
    },
    yScale: {
      spaceComputing: "auto"
    },
    options: {
      animations: {
        enabled: true
      },
      dataGrouping: {
        enabled: true,
        groupCount: 2
      },
      drawRays: false,
      crossHair: {
        enabled: true
      }
    }
  });
  // TODO: responsive height, width
  // TODO: TELETYPE DISCORD RICH PRESENCE
  </script>
</body>
</html>
